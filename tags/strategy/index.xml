<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Strategy on Potato</title><link>https://sneaky-potato.github.io/tags/strategy/</link><description>Recent content in Strategy on Potato</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://sneaky-potato.github.io/tags/strategy/index.xml" rel="self" type="application/rss+xml"/><item><title>Fundamental Theorem of Software Engineering</title><link>https://sneaky-potato.github.io/til/fundamental-theorem-se/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://sneaky-potato.github.io/til/fundamental-theorem-se/</guid><description>&lt;div class="lead !mb-9 text-xl"&gt;
Solution to most of the problems when building software systems
&lt;/div&gt;
&lt;p&gt;The &lt;a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering"&gt;theorem&lt;/a&gt; simply states the following&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can solve any problem by introducing an extra level of indirection&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Isn&amp;rsquo;t this interesting? The more you read and think about it the context of software systems, the more it makes sense.
And that applies to all layers of abstraction that you know, starting from abstraction in programming languages like C++ to the abstraction in kernel modules and interfaces&lt;/p&gt;</description></item><item><title>The 37% Rule</title><link>https://sneaky-potato.github.io/til/37percent/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://sneaky-potato.github.io/til/37percent/</guid><description>&lt;div class="lead !mb-9 text-xl"&gt;
An algorithm which answers the ages old question- &lt;code&gt;is he/she the right one for me?&lt;/code&gt;
&lt;/div&gt;
&lt;p&gt;There are many problems where computer scientists employ interesting algorithms to solve them. One such problem which is often seen in real life is the problem of &lt;a href="https://en.wikipedia.org/wiki/Optimal_stopping"&gt;Optimal Stopping&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also known as &lt;a href="https://en.wikipedia.org/wiki/Secretary_problem"&gt;The Secretary problem&lt;/a&gt; (GFG article on the same- &lt;a href="https://www.geeksforgeeks.org/secretary-problem-optimal-stopping-problem/"&gt;here&lt;/a&gt;), say youâ€™re interviewing a group of applicants for a position, how do you maximize the chances of hiring the single best applicant in the pool? (Once a candidate is rejected, they are gone forever and cannot be recalled.)&lt;/p&gt;</description></item></channel></rss>