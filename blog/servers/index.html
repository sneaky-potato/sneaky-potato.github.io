<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>Sockets, servers and scalability | Potato</title><meta property="og:title" content="Sockets, servers and scalability | Potato"><meta name=twitter:title content="Sockets, servers and scalability | Potato"><meta itemprop=name content="Sockets, servers and scalability | Potato"><meta name=application-name content="Sockets, servers and scalability | Potato"><meta property="og:site_name" content="Awesome hugo blog"><meta name=description content="linux, networks, sockets"><meta itemprop=description content="linux, networks, sockets"><meta property="og:description" content="linux, networks, sockets"><meta name=twitter:description content="linux, networks, sockets"><meta property="og:locale" content="en-us"><meta name=language content="en-us"><link rel=alternate hreflang=en href=https://sneaky-potato.github.io/blog/servers/ title><meta name=generator content="Hugo 0.154.5"><meta property="og:url" content="https://sneaky-potato.github.io/blog/servers/"><meta property="og:site_name" content="Potato"><meta property="og:title" content="Sockets, servers and scalability"><meta property="og:description" content="linux, networks, sockets"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-10-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-25T00:00:00+00:00"><meta property="article:tag" content="Tech"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sockets, servers and scalability"><meta name=twitter:description content="linux, networks, sockets"><link rel=canonical href=https://sneaky-potato.github.io/blog/servers/><link href=/style.min.2d921c18cf1ec555ffc03d59a8adc211c402c68c930c27d6a0c306ab175a8d09.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/icons/favicon-16x16.png><link rel=mask-icon href=/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=/favicon.ico><link rel=manifest href=https://sneaky-potato.github.io/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=/icons/favicon.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin=anonymous crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity="sha512-LQNxIMR5rXv7o+b1l8+N1EZMfhG7iFZ9HhnbJkTp4zjNr5Wvst75AqUeFDxeRUa7l5vEDyUiAip//r+EFLLCyA==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script></head><body data-theme=light class=notransition><script src=/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://sneaky-potato.github.io/ class=logo><svg width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>Home</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/>Home</a></li><li><a class="menu-link active" href=/blog/>Blog</a></li><li><a class=menu-link href=/about/>About</a></li><li><a class=menu-link href=/cv.pdf>CV</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg>
<svg class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>Sockets, servers and scalability</h1><div class=post-meta><time datetime=2025-10-25T00:00:00+00:00 itemprop=datePublished>Oct 25, 2025</time></div></header><div class=page-content><h1 id=scaling-a-server-to-handle-many-requests>Scaling a server to handle many requests</h1><blockquote><p>Everyone can talk, listening is where the actual difficulty lies.</p></blockquote><p>Caution: If the word <em><strong>socket</strong></em> does not ring any bells in your mind, this article will be difficult for you to follow.</p><h2 id=bare-bones-server>Bare bones server</h2><p>At the time of writing this article, I am employed as a fullstack software engineer and a lot of my work intersects with writing backend microservices.
Microservices that scale for traffic. I primarily use <a href=https://go.dev/>Go</a> to write these backend APIs.
Often times, I think about how backend servers are implemented internally and I decided to research a bit on the topic and that is the discussion of this very article.
So if you are someone who has written any form of backend APIs, web servers or network programming, this article is going to be perfect for you.</p><p>Let us start our discussion using first princple thinking, which I like to apply to any new problem which is thrown at me.
So, what are web servers actually? Having done my networks course in C, I would have answered this question with one word: <em><strong>socket</strong></em>.</p><h3 id=socket>Socket</h3><p>Sockets are abstractions of connections. For simplicity you can think of a socket as a tuple of size 5 containing the following information:</p><p><code>(src IP, src port, dst IP, dst port, protocol)</code></p><p>where <code>src IP</code> = source IP address, <code>src port</code> = source port, <code>dst IP</code> = destination IP address, <code>dst port</code> = destination port and <code>protocol</code> is either TCP or UDP.
So a socket in essence is a connection using port and protocol. This leads us to an important conclusion.</p><p>Therefore, you could open two sockets, a TCP and a UDP on the same port, StackOverflow answer <a href=https://stackoverflow.com/questions/6437383/can-tcp-and-udp-sockets-use-the-same-port>here</a></p><h3 id=how-to-open-a-socket>How to open a socket</h3><p>Let&rsquo;s look at all the steps involved while opening a socket for serving an incoming request.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> server_fd;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in addr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>server_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// SOCK_STREAM = TCP
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (server_fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;socket&#34;</span>); <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>addr.sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY;
</span></span><span style=display:flex><span>addr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#ae81ff>9000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>bind</span>(server_fd, (<span style=color:#66d9ef>struct</span> sockaddr<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;bind&#34;</span>); <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 5 connection requests will be queued before further requests are refused.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>listen</span>(server_fd, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;listen&#34;</span>); <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>); }
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Listening on port 9000...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><p>This will open a listening TCP socket on port 9000. But we cannot connect to it yet, for that we need to add the logic when a client connects to this socket.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// accept a connection
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(server_fd, NULL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client_fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;accept&#34;</span>); <span style=color:#66d9ef>continue</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Client connected.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// read whatever client writes to the socket
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// this is a blocking call
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>ssize_t</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(client_fd, buf, <span style=color:#66d9ef>sizeof</span>(buf));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// client closed or error
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// echo back whatever client writes
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>write</span>(client_fd, buf, n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Client disconnected.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(client_fd);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>close</span>(server_fd);
</span></span></code></pre></div><p>I want the readers to look into the <code>read()</code> system call, it is a blocking call. Which means the program will not proceed ahead until it has read
whatever content client wants to send. And this is only natural: <strong>You have to wait and read what the client wants to say</strong>.</p><p>This leads us to an important conclusion: this code can only handle <strong>one client request</strong> at a time, which can be verified using netcat.
If a request arrives when this server is serving an already existing connection, it has to wait.</p><p>This is not very good, let us improve this design.</p><h2 id=forked-server>Forked server</h2><p>To enable the process to serve more than one client, we could replicate the process altogether using <code>fork()</code> system call, right?
<strong>Yes</strong> we can do that, let us try this approach. Update the main loop as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(server_fd, NULL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client_fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;accept&#34;</span>); <span style=color:#66d9ef>continue</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;fork&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(client_fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Child process
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(server_fd); <span style=color:#75715e>// child doesn&#39;t need the listening socket
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[Child %d] Client connected.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getpid</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>ssize_t</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(client_fd, buf, <span style=color:#66d9ef>sizeof</span>(buf));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// client closed or error
</span></span></span><span style=display:flex><span>            <span style=color:#a6e22e>write</span>(client_fd, buf, n); <span style=color:#75715e>// echo back
</span></span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[Child %d] Client disconnected.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getpid</span>());
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(client_fd);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Parent process
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(client_fd); <span style=color:#75715e>// parent doesn’t handle this connection
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the process makes a copy of itself to serve an incoming request, this lets the server cater to many concurrent requests. But how many?</p><h3 id=performance>Performance</h3><p>Compile the forked server and run it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -o forked_server forked_server.c
</span></span><span style=display:flex><span>./forked_server
</span></span></code></pre></div><p>Inside another terminal connect to it using netcat (make 3 different connections)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nc localhost <span style=color:#ae81ff>9000</span>
</span></span></code></pre></div><p>Do this 2 more times in different terminals.</p><p>Measure the memory usage using ps</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -o pid,rss,cmd -C forked_server
</span></span></code></pre></div><p>This will give output somthing similar to this</p><pre tabindex=0><code>  PID   RSS CMD
49006  1568 ./forked_server
49244  1276 ./forked_server
49513  1276 ./forked_server
</code></pre><p>So this means, the 3 connections have peak memory usage as 1568KB (1.5MB), 1276KB (1.2MB) and 1276KB (1.2MB) respectively.</p><p>This approach works fine for small loads, but hits limits fast when scaling up. Replicating a process comes with memory overhead, also the OS has limited process ids.</p><table><thead><tr><th>Limit</th><th>Explanation</th><th>Symptom</th></tr></thead><tbody><tr><td><strong>Memory per process</strong></td><td>Each process has its own address space (~1–2 MB minimum)</td><td>Memory spikes with 1000+ clients</td></tr><tr><td><strong>Context switch</strong></td><td>Kernel must constantly switch between thousands of processes</td><td>High CPU, slow response</td></tr><tr><td><strong>PID</strong></td><td>Linux has finite number of process IDs</td><td>fork: Resource temporarily unavailable</td></tr><tr><td><strong>File descriptor</strong></td><td>Each process inherits its own FD table</td><td>&ldquo;Too many open files&rdquo; errors</td></tr></tbody></table><p>The conclusion that we can draw from here is: <strong>this approach scales linearly until OS overhead takes over, then collapses</strong>.</p><p>If processes are expensive, what about threads? Aren&rsquo;t those light weight processes?</p><h2 id=threads>Threads</h2><p>Surely, we can make the program better by multithreaded each request?
Update the main loop like so.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>client_fd) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(server_fd, NULL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>client_fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;accept&#34;</span>); <span style=color:#a6e22e>free</span>(client_fd); <span style=color:#66d9ef>continue</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pthread_t</span> tid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>pthread_create</span>(<span style=color:#f92672>&amp;</span>tid, NULL, handle_client, client_fd) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;pthread_create&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(<span style=color:#f92672>*</span>client_fd);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(client_fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pthread_detach</span>(tid); <span style=color:#75715e>// don&#39;t need to join later
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>close</span>(server_fd);
</span></span></code></pre></div><p>And define the handler function for the thread like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>handle_client</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>arg) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)arg;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(arg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[Thread %ld] Client connected.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>pthread_self</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ssize_t</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(client_fd, buf, <span style=color:#66d9ef>sizeof</span>(buf));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>write</span>(client_fd, buf, n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[Thread %ld] Client disconnected.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>pthread_self</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(client_fd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=performance-1>Performance</h3><p>Threads are better than the previous approach, but they also fail to serve beyond 1k concurrent requests.
Each thread consumes 1MB stack + scheduler state.</p><table><thead><tr><th>Limitation</th><th>Explanation</th><th>Symptom</th></tr></thead><tbody><tr><td><strong>Memory per thread</strong></td><td>10k threads × 1MB ≈ 10GB just for stacks</td><td>Out of memory</td></tr><tr><td><strong>Context switch</strong></td><td>Thousands of runnable threads cause kernel thrashing</td><td>CPU usage spikes to 100% even when idle</td></tr><tr><td><strong>File descriptor</strong></td><td>Each socket = 1 FD; OS default often 1024</td><td><code>accept: Too many open files</code></td></tr><tr><td><strong>Synchronization</strong></td><td>If you share data between threads</td><td>Lock contention, latency</td></tr></tbody></table><p>What is the next step, how can we make this any better, how can we scale this simple echo server to 10k requests?</p><h2 id=epoll>Epoll</h2><p>The problem is <code>read()</code> system call, which is blocking in nature. We have to wait for the client to write to the file descriptor and then only we can move ahead.</p><p>So the problem boils down to the synchronouse nature of listening: you wait and listen what the talking party has to say. But what about when the talking party
is not saying anything at the moment? Surely you can utilize that time to listen to other talking party who want to say something right?</p><p>This mean, there is a need of event driven architecture. Something that bring asynchonity to the model.
How about an event queue, if some client writes to a socket, we push an event and tell our program to read. This way we will only read when the client writes.</p><p>This can be done by the <code>epoll()</code> system call.</p><p>Imagine a queue of I/O readiness events. You tell the kernel: <strong>Please watch these sockets and wake me when they have something to do.</strong></p><p>Then the kernel keeps track of all those sockets for you.</p><p>There are three main system calls:</p><table><thead><tr><th>Call</th><th>Purpose</th><th>Analogy</th></tr></thead><tbody><tr><td><code>epoll_create1()</code></td><td>Create a new epoll instance (kernel event manager)</td><td>Create an empty watch list</td></tr><tr><td><code>epoll_ctl()</code></td><td>Add / remove / modify which FDs you want to watch</td><td>Add items to your interest list</td></tr><tr><td><code>epoll_wait()</code></td><td>Block until one or more watched FDs become ready</td><td>Wait for events to appear in the ready queue</td></tr></tbody></table><ol><li>Create an epoll instance</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> epfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>epoll_create1</span>(<span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>This gives you a handle to an internal epoll object in the kernel.</p><ol start=2><li>Register sockets to watch</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> epoll_event ev;
</span></span><span style=display:flex><span>ev.events <span style=color:#f92672>=</span> EPOLLIN;    <span style=color:#75715e>// interested in read
</span></span></span><span style=display:flex><span>ev.data.fd <span style=color:#f92672>=</span> sock;
</span></span><span style=display:flex><span><span style=color:#a6e22e>epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sock, <span style=color:#f92672>&amp;</span>ev);
</span></span></code></pre></div><p>This tranlates to a request to kernel</p><blockquote><p>When data arrives on socket sock, add an event for it to my internal ready list</p></blockquote><ol start=3><li>Wait for events</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> epoll_event events[MAX_EVENTS];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>epoll_wait</span>(epfd, events, MAX_EVENTS, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><p>This call sleeps until any socket you registered becomes ready.
When something happens, <code>epoll_wait()</code> returns with up to <code>MAX_EVENTS</code> ready sockets.</p><p>You then loop through:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> events[i].data.fd;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// read or write as needed
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>epoll is the better alternative to <code>poll</code> and <code>select</code> system calls.
However epoll’s complexity is roughly O(1) per ready FD, while select()/poll() are O(N) per call.</p><h1 id=why-it-scales>Why It Scales?</h1><ul><li>One kernel data structure holds all your FDs.</li><li>Wake-ups happen only when necessary.</li><li>No linear scanning through all sockets like in <code>select()</code>or <code>poll()</code>.</li></ul><p>That’s why epoll is the engine behind:</p><ul><li>nginx</li><li>Redis</li><li>Node.js</li><li>Go runtime’s netpoller</li></ul><p>Following table summarises the whole discussion</p><table><thead><tr><th>Model</th><th>Memory per conn</th><th>Kernel objects</th><th>Max connections</th><th>Typical use</th></tr></thead><tbody><tr><td><code>fork()</code></td><td>~1–2 MB</td><td>process + fd</td><td>500–1k</td><td>legacy UNIX daemons</td></tr><tr><td><code>pthread</code></td><td>~1 MB</td><td>thread + fd</td><td>1k–5k</td><td>simple chat/web servers</td></tr><tr><td><code>epoll()</code></td><td>~few KB</td><td>fd only</td><td>100k+</td><td>modern high-performance servers (nginx, Go, Rust, etc.)</td></tr></tbody></table></div></article><script src=https://utteranc.es/client.js repo=sneaky-potato/sneaky-potato.github.io issue-term=pathname label=comment theme=github-dark-orange crossorigin=anonymous async></script></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://github.com/sneaky-potato target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div><small class=footer_copyright>© 2026 Ashwani Kumar Kamal.
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel=noopener>Hugo blog awesome</a>.</small></footer><a href=# title="Go to top" id=totop><svg width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"/></svg>
</a><script src=https://sneaky-potato.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30+lSNuSkl4QXuNyy8="></script></body></html>