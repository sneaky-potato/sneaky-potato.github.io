<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Open Source on Potato</title><link>https://sneaky-potato.github.io/oss/</link><description>Recent content in Open Source on Potato</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 31 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://sneaky-potato.github.io/oss/index.xml" rel="self" type="application/rss+xml"/><item><title>Lunatik, lua inside kernel boundary</title><link>https://sneaky-potato.github.io/oss/lunatik-kernel-lua/</link><pubDate>Sat, 31 Jan 2026 00:00:00 +0000</pubDate><guid>https://sneaky-potato.github.io/oss/lunatik-kernel-lua/</guid><description>&lt;div class="lead !mb-9 text-xl"&gt;
Controlling low level components with a high level language
&lt;/div&gt;
&lt;h2 id="what"&gt;What?&lt;/h2&gt;
&lt;p&gt;Lunatik is a framework for scripting the Linux kernel using Lua. It allows developers to write kernel-resident logic in a high-level language, while still interacting directly with kernel facilities such as networking, devices, timing, and system state.&lt;/p&gt;
&lt;p&gt;At a high level, Lunatik consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A modified Lua interpreter that runs inside the Linux kernel&lt;/li&gt;
&lt;li&gt;A kernel-space C API to manage Lua runtimes and execute scripts&lt;/li&gt;
&lt;li&gt;Lua-based device driver layer&lt;/li&gt;
&lt;li&gt;User-space CLI tool (lunatik) to load, run, and manage kernel Lua environments&lt;/li&gt;
&lt;li&gt;Lua bindings that expose kernel facilities to Lua scripts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This architecture allows Lua to be used as a control and orchestration language inside the kernel, enabling rapid prototyping, instrumentation, and kernel-adjacent logic without writing everything in C.&lt;/p&gt;</description></item><item><title>Trivy, Go's init(), and the Magic of Dynamic Analyzer Discovery</title><link>https://sneaky-potato.github.io/oss/trivy-analyzers/</link><pubDate>Tue, 07 Oct 2025 00:00:00 +0000</pubDate><guid>https://sneaky-potato.github.io/oss/trivy-analyzers/</guid><description>&lt;div class="lead !mb-9 text-xl"&gt;
How Trivy Dynamically Discovers New File Format Analyzers in Go
&lt;/div&gt;
&lt;h2 id="what"&gt;What?&lt;/h2&gt;
&lt;p&gt;I want to discuss a particular design pattern in go through a &lt;a href="https://github.com/aquasecurity/trivy/pull/8897"&gt;PR&lt;/a&gt; which I raised in the open source project &lt;a href="https://github.com/aquasecurity/trivy"&gt;trivy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="what-is-trivy"&gt;What is trivy?&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://trivy.dev"&gt;Trivy&lt;/a&gt; is an open source vulnerability scanner. You could use Trivy to find vulnerabilities (CVE) &amp;amp; misconfigurations (IaC) across code repositories, binary artifacts, container images, Kubernetes clusters, and more.&lt;/p&gt;
&lt;p&gt;Since it is open source it used in extensively in build and deploy pipelines across projects. I used trivy in my build pipelines to scan images, configuration, licenses and most importantly - &lt;strong&gt;vulnerabilities&lt;/strong&gt; in the source code.&lt;/p&gt;</description></item></channel></rss>